# Comprehensive Vulnerability Testing Guide

This document provides detailed commands, expected outputs, and explanations for each vulnerability in the backend demo.

## Table of Contents

1. [Trello-style Email Enumeration](#1-trello-style-email-enumeration)
2. [TTIBI-style Password in Error Logs](#2-ttibi-style-password-in-error-logs)
3. [Spoutible-style Public API with Full User Object](#3-spoutible-style-public-api-with-full-user-object)
4. [GitHub-style Secrets in Config Files](#4-github-style-secrets-in-config-files)
5. [PandaBuy-style Mass Scraping Vulnerabilities](#5-pandabuy-style-mass-scraping-vulnerabilities)
6. [Microsoft Graph-style Cloud API Patterns](#6-microsoft-graph-style-cloud-api-patterns)
7. [Dropbox Sign-style Overprivileged Service Accounts](#7-dropbox-sign-style-overprivileged-service-accounts)
8. [Dell-style Partner Portal with No Rate Limiting](#8-dell-style-partner-portal-with-no-rate-limiting)
9. [IDOR (Insecure Direct Object Reference)](#9-idor-insecure-direct-object-reference)
10. [Missing Authentication on Admin Endpoints](#10-missing-authentication-on-admin-endpoints)

---

## 1. Trello-style Email Enumeration

### Vulnerability
Unauthenticated endpoint that leaks user existence through different responses for valid vs invalid emails.

### Commands

```bash
# Test with valid email (known user)
curl -v http://localhost:3000/api/members/alice@example.com

# Test with invalid email (non-existent user)
curl -v http://localhost:3000/api/members/nonexistent@example.com
```

### Expected Outputs

**Valid Email (200 OK):**
```json
{
  "id": "1",
  "username": "alice",
  "email": "alice@example.com",
  "avatar": "https://api.example.com/avatars/1.png",
  "full_name": "alice",
  "bio": "This is alice's profile",
  "member_since": "2023-01-01T00:00:00Z",
  "last_seen": "2024-01-15T10:30:00Z"
}
```

**Invalid Email (404 Not Found):**
```json
{
  "error": "Member not found",
  "message": "No member found with identifier: nonexistent@example.com"
}
```

### Why This Is Bad

1. **User Enumeration Attack**: Attackers can determine which email addresses are registered in the system
2. **Privacy Violation**: Reveals personal information (email addresses) without consent
3. **Phishing Vector**: Attackers can build targeted email lists for phishing campaigns
4. **GDPR/Privacy Law Violations**: May violate data protection regulations
5. **Account Takeover Preparation**: First step in targeted attacks (password reset, credential stuffing)

### Real-World Impact

- **Trello (2023)**: Attackers could enumerate millions of email addresses by testing `/members/{email}` endpoint
- **LinkedIn**: Similar issues allowed scraping of user profiles
- **Impact**: Millions of users' email addresses exposed, enabling targeted attacks

### Secure Alternative

```bash
# Secure endpoint requires authentication
curl http://localhost:3000/api/members/alice@example.com/secure \
  -H "Authorization: Bearer YOUR_TOKEN"
```

---

## 2. TTIBI-style Password in Error Logs

### Vulnerability
Error responses contain SMTP logs with Base64-encoded passwords and credentials.

### Commands

```bash
# First, get a token
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","password":"any"}' | jq -r '.token')

# Trigger error by sending malformed request
curl -v -X POST http://localhost:3000/api/send-email \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"to":"test@example.com"}'
```

### Expected Output (500 Error)

```json
{
  "error": "Failed to send email",
  "details": "SMTP connection failed",
  "smtp_log": [
    "220 smtp.example.com ESMTP",
    "EHLO api.example.com",
    "250-AUTH LOGIN PLAIN",
    "250-AUTH LOGIN bm9yZXBseUBleGFtcGxlLmNvbQ==",
    "535 Authentication failed: c210cF9wYXNzd29yZF9zZWNyZXRfMTIzNDU=",
    "Connection closed"
  ],
  "debug_info": {
    "smtp_host": "smtp.example.com",
    "smtp_user": "noreply@example.com",
    "smtp_password_b64": "c210cF9wYXNzd29yZF9zZWNyZXRfMTIzNDU=",
    "timestamp": "2024-01-15T12:00:00.000Z"
  }
}
```

**Decoded Base64:**
```bash
echo "c210cF9wYXNzd29yZF9zZWNyZXRfMTIzNDU=" | base64 -d
# Output: smtp_password_secret_12345
```

### Why This Is Bad

1. **Credential Exposure**: Passwords and secrets leaked in error responses
2. **No Authentication Required for Errors**: Error paths may bypass normal security checks
3. **Logging Vulnerabilities**: Sensitive data in logs can be accessed via error endpoints
4. **Attack Surface**: Any error condition can leak secrets
5. **Compliance Violations**: Violates security standards (PCI-DSS, SOC 2, etc.)

### Real-World Impact

- **TTIBI (2024)**: Email API errors contained SMTP logs with Base64-encoded passwords
- **Impact**: Attackers could extract SMTP credentials from error responses
- **Consequence**: Email account compromise, spam sending, further attacks

### Secure Alternative

```bash
# Secure endpoint returns generic error
curl -X POST http://localhost:3000/api/send-email/secure \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"to":"test@example.com","subject":"Test","body":"Test"}'
```

**Secure Response:**
```json
{
  "error": "Failed to send email",
  "message": "An error occurred while sending the email. Please try again later."
}
```

---

## 3. Spoutible-style Public API with Full User Object

### Vulnerability
Public endpoint (no authentication required) returns complete user object including password hashes, 2FA secrets, reset tokens, and all PII.

### Commands

```bash
# No authentication required - public endpoint
curl -v "http://localhost:3000/api/user_profile_box?username=alice"

# Or by user ID
curl -v "http://localhost:3000/api/user_profile_box?user_id=1"
```

### Expected Output (200 OK)

```json
{
  "id": "1",
  "username": "alice",
  "email": "alice@example.com",
  "phone": "+1-555-0101",
  "address": "123 Main St, Anytown, USA",
  "postcode": "12345",
  "ip_address": "192.168.1.100",
  "password": "$2b$10$rOzJqKqKqKqKqKqKqKqKqOeKqKqKqKqKqKqKqKqKqKqKqKqKqKqKq",
  "password_hash": "$2b$10$rOzJqKqKqKqKqKqKqKqKqOeKqKqKqKqKqKqKqKqKqKqKqKqKqKq",
  "two_factor_secret": "JBSWY3DPEHPK3PXP",
  "backup_codes": ["123456", "789012", "345678"],
  "em_code": "EM123456789",
  "reset_token": "reset_token_abc123",
  "auth_token": "auth_token_xyz789",
  "last_login": "2024-01-15T10:30:00Z",
  "role": "admin",
  "created_at": "2023-01-01T00:00:00Z"
}
```

### Why This Is Bad

1. **Complete Account Compromise**: All authentication secrets exposed
2. **Password Hash Exposure**: Enables offline brute-force attacks
3. **2FA Bypass**: Backup codes and 2FA secrets exposed
4. **Account Takeover**: Reset tokens and auth tokens can be used immediately
5. **PII Exposure**: Full personal information (email, phone, address) exposed
6. **No Authentication**: Anyone can access any user's complete data
7. **Mass Data Breach**: Can be scraped for all users

### Real-World Impact

- **Spoutible (2024)**: Public API endpoint `/user_profile_box` returned full user objects
- **Impact**: All user accounts compromised, passwords, 2FA secrets, reset tokens exposed
- **Consequence**: Complete platform compromise, user account takeovers

### Secure Alternative

```bash
# Secure endpoint returns minimal public info
curl "http://localhost:3000/api/user_profile_box/secure?username=alice"
```

**Secure Response:**
```json
{
  "id": "1",
  "username": "alice",
  "avatar": "https://api.example.com/avatars/1.png",
  "created_at": "2023-01-01T00:00:00Z"
}
```

---

## 4. GitHub-style Secrets in Config Files

### Vulnerability
Hardcoded secrets, API keys, and credentials in configuration files and environment files.

### Commands

```bash
# Check for secrets in .env file
cat backend-demo/.env

# Check config files
cat backend-demo/config/secrets.js
cat backend-demo/config/database.json
```

### Expected Outputs

**.env file:**
```bash
AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
DB_PASS=super_secret_password_123
OAUTH_CLIENT_SECRET=abcdefghijklmnopqrstuvwxyz123456
STRIPE_SECRET_KEY=sk_test_51AbCdEfGhIjKlMnOpQrStUvWxYz1234567890
```

**config/secrets.js:**
```javascript
aws: {
  accessKeyId: 'AKIAIOSFODNN7EXAMPLE',
  secretAccessKey: 'wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY'
},
stripe: {
  secretKey: 'sk_test_51AbCdEfGhIjKlMnOpQrStUvWxYz1234567890'
}
```

### Why This Is Bad

1. **Version Control Exposure**: Secrets committed to Git are permanently in history
2. **Broad Access**: Anyone with repo access gets all secrets
3. **No Rotation**: Hardcoded secrets are rarely rotated
4. **Compliance Violations**: Violates security standards and regulations
5. **Supply Chain Risk**: Third-party tools scanning repos can find secrets
6. **Credential Reuse**: Same secrets often used across environments
7. **No Audit Trail**: Can't track who accessed secrets

### Real-World Impact

- **GitHub/GitGuardian**: Millions of secrets found in public repositories
- **Impact**: AWS accounts compromised, databases accessed, services hijacked
- **Consequence**: Data breaches, financial loss, service disruption

### Secure Alternative

- Use environment variables (not committed to Git)
- Use secret management services (AWS Secrets Manager, HashiCorp Vault)
- Use `.gitignore` to exclude `.env` files
- Rotate secrets regularly
- Use different secrets per environment

---

## 5. PandaBuy-style Mass Scraping Vulnerabilities

### Vulnerability
Multiple endpoints with weak/no authentication, enumerable IDs, full PII exposure, and no rate limiting.

### Commands

```bash
# Enumerate orders (weak auth - optionalAuth middleware)
curl http://localhost:3000/api/orders/1
curl http://localhost:3000/api/orders/2
curl http://localhost:3000/api/orders/3
# ... continue to 1000

# Enumerate customers (NO AUTH)
curl http://localhost:3000/api/customer/1
curl http://localhost:3000/api/customer/2
curl http://localhost:3000/api/customer/3
curl http://localhost:3000/api/customer/4

# Automated enumeration script
for i in {1..100}; do
  curl -s http://localhost:3000/api/orders/$i | jq '.customer.email'
done
```

### Expected Outputs

**Order Endpoint (200 OK):**
```json
{
  "id": "1",
  "order_number": "ORD000001",
  "customer": {
    "id": "1",
    "name": "alice",
    "email": "alice@example.com",
    "address": "123 Main St, Anytown, USA",
    "phone": "+1-555-0101"
  },
  "items": [{"name": "Product 1", "quantity": 1, "price": 99.99}],
  "total": 99.99,
  "status": "processing",
  "created_at": "2024-01-01T00:00:00.000Z"
}
```

**Customer Endpoint (200 OK):**
```json
{
  "id": "1",
  "username": "alice",
  "email": "alice@example.com",
  "phone": "+1-555-0101",
  "address": "123 Main St, Anytown, USA",
  "postcode": "12345",
  "ip_address": "192.168.1.100",
  "orders": [
    {"id": "1", "order_number": "ORD000001", "total": 99.99, "status": "processing"}
  ]
}
```

### Why This Is Bad

1. **Mass Data Breach**: Can scrape millions of records
2. **No Authentication**: Customer endpoint requires no auth
3. **Enumerable IDs**: Sequential IDs make enumeration trivial
4. **Full PII Exposure**: Complete customer data in every response
5. **No Rate Limiting**: Can make unlimited requests
6. **No Access Control**: Users can access other users' data
7. **Privacy Violation**: Massive GDPR/privacy law violations

### Real-World Impact

- **PandaBuy (2024)**: Attackers scraped 1.3 million customer records
- **Impact**: All customer PII exposed (names, addresses, emails, phone numbers)
- **Consequence**: Identity theft, targeted attacks, regulatory fines

### Secure Alternative

```bash
# Secure endpoint with proper auth and IDOR protection
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","password":"any"}' | jq -r '.token')

curl http://localhost:3000/api/orders/1/secure \
  -H "Authorization: Bearer $TOKEN"
```

**Secure Response (only user's own orders):**
```json
{
  "id": "1",
  "order_number": "ORD000001",
  "items": [{"name": "Product 1", "quantity": 1, "price": 99.99}],
  "total": 99.99,
  "status": "processing",
  "created_at": "2024-01-01T00:00:00.000Z"
}
```

---

## 6. Microsoft Graph-style Cloud API Patterns

### Vulnerability
Service accounts with high privileges used for suspicious file polling patterns (potential C2/command-and-control indicators).

### Commands

```bash
# Use service account token
curl http://localhost:3000/api/service/graph/drive/root/c2/commands.txt \
  -H "Authorization: Bearer svc_token_graph_api_67890"

# Suspicious path pattern
curl http://localhost:3000/api/service/graph/drive/root/commands.txt \
  -H "Authorization: Bearer svc_token_graph_api_67890"
```

### Expected Output (Suspicious Pattern)

```json
{
  "path": "c2/commands.txt",
  "content": "c3VzcGljaW91c19jb21tYW5kX3BheWxvYWQ=",
  "timestamp": "2024-01-15T12:00:00.000Z",
  "warning": "This pattern matches known C2 indicators"
}
```

**Decoded Base64:**
```bash
echo "c3VzcGljaW91c19jb21tYW5kX3BheWxvYWQ=" | base64 -d
# Output: suspicious_command_payload
```

### Why This Is Bad

1. **C2 Abuse**: Legitimate cloud APIs used for command-and-control
2. **High Privilege Tokens**: Service accounts often have broad permissions
3. **Stealth**: Looks like legitimate API usage
4. **Data Exfiltration**: Can be used to exfiltrate data
5. **Persistence**: Hard to detect and remove
6. **Compliance Risk**: Violates cloud provider terms of service

### Real-World Impact

- **Microsoft Graph Abuse**: Attackers use Graph API for C2 communication
- **Impact**: Malware persistence, data exfiltration, lateral movement
- **Consequence**: Complete network compromise, data breaches

### Detection Indicators

- Frequent polling of specific file paths
- Base64-encoded content in file operations
- Service account tokens used for file operations
- Unusual access patterns (e.g., `/c2/`, `/commands/` paths)

---

## 7. Dropbox Sign-style Overprivileged Service Accounts

### Vulnerability
Service accounts with broad, unrestricted access to all customer data without proper scoping.

### Commands

```bash
# Use service account token
curl http://localhost:3000/api/service/customers \
  -H "Authorization: Bearer svc_token_sign_prod_12345"
```

### Expected Output (200 OK)

```json
{
  "service_account": "SIGN_PROD_SVC_ACCOUNT",
  "permissions": ["read:all", "write:all", "admin:all"],
  "customers": [
    {
      "id": "1",
      "email": "alice@example.com",
      "username": "alice",
      "phone": "+1-555-0101",
      "address": "123 Main St, Anytown, USA",
      "password_hash": "$2b$10$rOzJqKqKqKqKqKqKqKqKqOeKqKqKqKqKqKqKqKqKqKqKqKqKqKqKq",
      "two_factor_secret": "JBSWY3DPEHPK3PXP",
      "orders": [...]
    },
    {
      "id": "2",
      "email": "bob@example.com",
      ...
    }
  ]
}
```

### Why This Is Bad

1. **Overprivileged Access**: Service accounts have access to ALL customer data
2. **No Scoping**: No principle of least privilege
3. **Non-Human Access**: Used by automation, harder to monitor
4. **Long-Lived Tokens**: Service tokens rarely rotated
5. **Single Point of Failure**: Compromise of one token = all data
6. **No MFA**: Service accounts can't use multi-factor authentication
7. **Audit Challenges**: Hard to track what service accounts access

### Real-World Impact

- **Dropbox Sign (2024)**: Service account had access to all customer databases
- **Impact**: Complete customer data exposure if token compromised
- **Consequence**: Data breach, regulatory fines, customer trust loss

### Secure Alternative

- Implement least privilege (only access needed data)
- Scope service accounts to specific resources
- Rotate service account tokens regularly
- Monitor service account access patterns
- Use IP allowlists for service accounts
- Implement time-based access controls

---

## 8. Dell-style Partner Portal with No Rate Limiting

### Vulnerability
Partner endpoint allows enumeration of service tags with full customer PII, no rate limiting, and predictable identifiers.

### Commands

```bash
# Login as partner
PARTNER_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"diana@example.com","password":"any"}' | jq -r '.token')

# Enumerate service tags
curl http://localhost:3000/api/partner/orders/ABC1234 \
  -H "Authorization: Bearer $PARTNER_TOKEN"

curl http://localhost:3000/api/partner/orders/ABC1235 \
  -H "Authorization: Bearer $PARTNER_TOKEN"

# Rapid enumeration (no rate limiting)
for i in {0..99}; do
  curl -s http://localhost:3000/api/partner/orders/ABC12$i \
    -H "Authorization: Bearer $PARTNER_TOKEN" | jq '.customer.email'
done
```

### Expected Output (200 OK)

```json
{
  "service_tag": "ABC1234",
  "model": "Dell Laptop Model 0",
  "serial_number": "SNABC12340",
  "warranty_status": "active",
  "purchase_date": "2023-01-01T00:00:00.000Z",
  "customer": {
    "id": "1",
    "name": "alice",
    "email": "alice@example.com",
    "address": "123 Main St, Anytown, USA"
  }
}
```

### Why This Is Bad

1. **Enumerable Identifiers**: 7-character alphanumeric tags are predictable
2. **No Rate Limiting**: Can make unlimited rapid requests
3. **Full PII Exposure**: Complete customer data in every response
4. **Mass Scraping**: Can enumerate millions of service tags
5. **Partner Abuse**: Partner credentials can be used to scrape all data
6. **No Monitoring**: No alerts for unusual access patterns

### Real-World Impact

- **Dell (2024)**: Partner portal allowed enumeration of service tags
- **Impact**: Tens of millions of customer records scraped
- **Consequence**: Complete customer database exposure, regulatory investigation

### Secure Alternative

- Implement rate limiting (e.g., 60 requests/minute)
- Use non-enumerable identifiers (UUIDs, hashed IDs)
- Return minimal customer data
- Monitor for enumeration patterns
- Implement CAPTCHA after threshold
- Alert on unusual access patterns

---

## 9. IDOR (Insecure Direct Object Reference)

### Vulnerability
Users can access other users' data by changing the user ID in the URL, with no authorization check.

### Commands

```bash
# Login as regular user (bob, ID=2)
USER_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"bob@example.com","password":"any"}' | jq -r '.token')

# Bob tries to access Alice's data (ID=1)
curl http://localhost:3000/api/users/1 \
  -H "Authorization: Bearer $USER_TOKEN"

# Bob tries to access Charlie's data (ID=3)
curl http://localhost:3000/api/users/3 \
  -H "Authorization: Bearer $USER_TOKEN"
```

### Expected Output (200 OK - Should be 403)

```json
{
  "id": "1",
  "email": "alice@example.com",
  "username": "alice",
  "phone": "+1-555-0101",
  "address": "123 Main St, Anytown, USA",
  "ip_address": "192.168.1.100",
  "last_login": "2024-01-15T10:30:00Z"
}
```

### Why This Is Bad

1. **Unauthorized Access**: Users can access other users' private data
2. **Privacy Violation**: Complete PII exposure for any user
3. **No Authorization Check**: Only checks authentication, not ownership
4. **Easy Exploitation**: Just change the ID in the URL
5. **Mass Enumeration**: Can enumerate all user IDs
6. **Compliance Violation**: Violates GDPR, CCPA, and other privacy laws

### Real-World Impact

- **Facebook (2018)**: IDOR allowed access to private photos
- **Impact**: Millions of private photos exposed
- **Consequence**: Privacy violations, regulatory fines, user trust loss

### Secure Alternative

```bash
# Properly secured endpoint checks ownership
curl http://localhost:3000/api/users/1 \
  -H "Authorization: Bearer $USER_TOKEN"
```

**Secure Response (403 Forbidden):**
```json
{
  "error": "Access denied"
}
```

**Implementation:**
```javascript
// Check if user owns the resource
if (req.user.role !== 'admin' && req.params.id !== req.user.id) {
  return res.status(403).json({ error: 'Access denied' });
}
```

---

## 10. Missing Authentication on Admin Endpoints

### Vulnerability
Admin endpoint requires authentication but not admin role, allowing any authenticated user to access admin functions.

### Commands

```bash
# Login as regular user (not admin)
USER_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"bob@example.com","password":"any"}' | jq -r '.token')

# Regular user accesses admin endpoint
curl http://localhost:3000/api/admin/users/vulnerable \
  -H "Authorization: Bearer $USER_TOKEN"
```

### Expected Output (200 OK - Should be 403)

```json
{
  "users": [
    {
      "id": "1",
      "email": "alice@example.com",
      "username": "alice",
      "phone": "+1-555-0101",
      "address": "123 Main St, Anytown, USA",
      "role": "admin",
      "created_at": "2023-01-01T00:00:00Z"
    },
    {
      "id": "2",
      "email": "bob@example.com",
      ...
    }
  ]
}
```

### Why This Is Bad

1. **Privilege Escalation**: Regular users gain admin access
2. **Role Bypass**: Authentication check without role check
3. **Data Exposure**: All user PII exposed to non-admins
4. **Compliance Violation**: Violates access control requirements
5. **Audit Failure**: Can't track who should have access

### Real-World Impact

- **Multiple Platforms**: Common vulnerability in many applications
- **Impact**: Unauthorized access to admin functions, data exposure
- **Consequence**: Security breaches, compliance violations

### Secure Alternative

```bash
# Properly secured endpoint requires admin role
ADMIN_TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"alice@example.com","password":"any"}' | jq -r '.token')

curl http://localhost:3000/api/admin/users \
  -H "Authorization: Bearer $ADMIN_TOKEN"
```

**Implementation:**
```javascript
router.get('/admin/users', requireAuth, requireRole('admin'), (req, res) => {
  // Only admins can access
});
```

---

## Summary of Security Best Practices

### Authentication & Authorization
- ✅ Always require authentication for sensitive endpoints
- ✅ Implement role-based access control (RBAC)
- ✅ Check resource ownership (IDOR protection)
- ✅ Use principle of least privilege

### Data Protection
- ✅ Never expose secrets in responses
- ✅ Never expose PII unnecessarily
- ✅ Use generic error messages
- ✅ Sanitize error responses

### Rate Limiting & Enumeration
- ✅ Implement rate limiting on sensitive endpoints
- ✅ Use non-enumerable identifiers (UUIDs)
- ✅ Monitor for enumeration patterns
- ✅ Implement CAPTCHA after thresholds

### Secrets Management
- ✅ Never commit secrets to version control
- ✅ Use environment variables or secret managers
- ✅ Rotate secrets regularly
- ✅ Use different secrets per environment

### Monitoring & Detection
- ✅ Log all access attempts
- ✅ Alert on unusual patterns
- ✅ Monitor service account usage
- ✅ Track enumeration attempts

---

## Testing Checklist

Use this checklist to verify all vulnerabilities:

- [ ] Email enumeration works (different responses for valid/invalid emails)
- [ ] Error responses contain secrets (Base64 passwords in errors)
- [ ] Public endpoints return full user objects with secrets
- [ ] Config files contain hardcoded secrets
- [ ] Orders can be enumerated without proper auth
- [ ] Customers can be accessed without auth
- [ ] Service tags can be enumerated rapidly
- [ ] Service accounts have overprivileged access
- [ ] IDOR allows accessing other users' data
- [ ] Admin endpoints don't check roles properly

---

## Legal & Ethical Notice

⚠️ **IMPORTANT**: This backend is for **testing and educational purposes only**. 

- Only test on systems you own or have explicit permission to test
- Do not use these techniques on production systems
- Do not scrape or enumerate real user data
- Respect privacy laws and regulations
- Report vulnerabilities responsibly through proper channels

